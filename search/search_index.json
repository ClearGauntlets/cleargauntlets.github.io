{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ClearWiki! This website is the home of the ClearGauntlets project, a fork of the LucidVR project focusing on refining the \"reel\" design of Prototype 4.1 to create a sleeker, more effective virtual reality glove. The main gimmick of this project is \"premium\" design. The price ceiling per pair is raised from $60 to $200, but for that, we hope to give you simpler, smaller, more reliable reels, a better PCB and wiring harness, and SteamVR tracking! Please bear with us as we build all this, it's really complicated. This website also hopes to become a resource for anyone looking to get into VR hacking, a starting place for learning the basic components of a VR system, a host for detailed descriptions, source code, schematics, and guides. Ideally, you will be able to go from zero to full pair of custom gloves just by clicking through this website. Find the rest of our stuff at https://github.com/cleargauntlets Projects ClearGauntlets is composed of a handful of projects designed to produce a premium, DIY-friendly pair of haptic feedback gloves. The project is essentially a glorified fork of the LucidVR project, and tries to maintain as much upstream compatibility as possible, with any deviations well-documented. CG Proto 2 Our re-design of LucidGloves Proto 4. The above link contains a read-only Onshape workspace. If you just want the STLs, click here PCB A compact PCB designed to break out all the IO you'll need in an extremely tight package. Power The power module used to drive the ESP32 and Servos (and, perhaps one day, a custom tracker) This doesn't exist yet. Hopefully it will soon. Firmware A fork of the LucidGloves project that we base our firmware off of. UI A fork of LucidVR's UI system. Driver Our Fork of the LucidVR Steam Windows Drivers Tracker A custom implementation of a Lighthouse V1 tracker. This is an extremely cheap way to enable tracking for your project.","title":"Home"},{"location":"#welcome-to-clearwiki","text":"This website is the home of the ClearGauntlets project, a fork of the LucidVR project focusing on refining the \"reel\" design of Prototype 4.1 to create a sleeker, more effective virtual reality glove. The main gimmick of this project is \"premium\" design. The price ceiling per pair is raised from $60 to $200, but for that, we hope to give you simpler, smaller, more reliable reels, a better PCB and wiring harness, and SteamVR tracking! Please bear with us as we build all this, it's really complicated. This website also hopes to become a resource for anyone looking to get into VR hacking, a starting place for learning the basic components of a VR system, a host for detailed descriptions, source code, schematics, and guides. Ideally, you will be able to go from zero to full pair of custom gloves just by clicking through this website. Find the rest of our stuff at https://github.com/cleargauntlets","title":"Welcome to ClearWiki!"},{"location":"#projects","text":"ClearGauntlets is composed of a handful of projects designed to produce a premium, DIY-friendly pair of haptic feedback gloves. The project is essentially a glorified fork of the LucidVR project, and tries to maintain as much upstream compatibility as possible, with any deviations well-documented.","title":"Projects"},{"location":"#cg-proto-2","text":"Our re-design of LucidGloves Proto 4. The above link contains a read-only Onshape workspace. If you just want the STLs, click here","title":"CG Proto 2"},{"location":"#pcb","text":"A compact PCB designed to break out all the IO you'll need in an extremely tight package.","title":"PCB"},{"location":"#power","text":"The power module used to drive the ESP32 and Servos (and, perhaps one day, a custom tracker) This doesn't exist yet. Hopefully it will soon.","title":"Power"},{"location":"#firmware","text":"A fork of the LucidGloves project that we base our firmware off of.","title":"Firmware"},{"location":"#ui","text":"A fork of LucidVR's UI system.","title":"UI"},{"location":"#driver","text":"Our Fork of the LucidVR Steam Windows Drivers","title":"Driver"},{"location":"#tracker","text":"A custom implementation of a Lighthouse V1 tracker. This is an extremely cheap way to enable tracking for your project.","title":"Tracker"},{"location":"photos/","text":"","title":"Photos"},{"location":"blogs/mat/mat/","text":"More Accessible Tracker In which a bozo attempts to do SteamVR tracking for cheap. Talking I\u00b2C, and a base for UART communication 2023-05-25 It's been a minute. I was busy with school and the rest of this MSD project, but I'm finished with all that now, and have decided to spend the rest of the summer working on this project, so hopefully there will be at least a few updates in the next few months. ...is what I would have said on the 11th of May, if I hadn't had a bout of health issues over the last couple weeks. I'm back now, and working on the project again, and have some exciting updates: I\u00b2C The FPGA has two components: a bootloader, and firmware. This design makes the board \"unbrickable,\" since you can always flash new firmware if you mess something up. Anyway, this page details how that bootloader protocol works. Initially, I was trying to talk to it over UART 1 on the solder pads exposed, but that proved to be an exercise in futility. Instead, I shoved some jumper cables into the crazyflie expansion ports present on the deck, and set up I\u00b2C on an ESP32. I didn't bother regulating the voltage, and simply talk to it at 3.3V. To check if it worked, I tested the \"Version\" command, then I sent it the requisite boot commands, and he booted right up! The LEDs went from \"Red and Blue\" to \"EVERYTHING!\" There appear to be UART commands you can send to change those LEDs, but that's not really required for operation, since this thing is mostly stateless, and just vomits pulse data at you, I guess. UART That's a nice little segue into the UART! Once the board is up, data spools in from UART0, once again located on those expansion pins. The protocol for that can be found documented in the lighthouse-fpga README , and you can find code for that in the Crazyflie firmware . The thing about this system that didn't really occur to me until I got in touch with Bitcraze about this project is that everything important happens onboard the crazyflie. This means that a large part of what the Vive Trackers do hasn't been implemented, that is, use 2.4GHz RF to talk to the PC so that it can do all of the solving. This is good news and bad news: Good news, I won't have to port much of their STM32 code to the ESP32, I basically just have to get the data and shunt it somewhere. Bad news: I have implement the shunting. Luckily, this seems to be a solved problem. Products like the Tundra Tracker SoC have a Nordic nRF52832 RF processor that deals with communication to the PC by way of their dongle, or perhaps a watchman dongle? (I don't know if this product would work with a Watchman dongle, but I imagine the tech is very similar). So, either I can do something fancy with the ESP32 (it has onboard 2.4GHz radios of some kind, maybe I can use those?), or I can bring in some Nordic chip to do that for me. Small issue: Cost. My digikey parts list is already up to $60 on its own, and that sucks! So, I'd like to figure out how to do all this with as little hardware as possible. But I'm getting ahead of myself. That's the next problem. Right now, I'm just trying to correctly interpret data from the deck (specifically, today, I'm learning about the sync pulses), and prepare it for... whatever's next (probably sending to the PC). After that, I'll probably need an IMU. I wrote this post as an update, since it's been so long. As I said, I wanted to send something out sooner, but I got sick. Hopefully in the next week or three, I'll have another update, and can begin working on the IMU and/or communication issues. Code, please? Sure! It's literally garbage right now, but you can find my repo here . All it does is boot up the board and vomit whatever it gets back on UART. Compiling the lighthouse-fpga project 2023-03-07 Hello again. I feel that this page is overdue for an update, so here's one: I've managed to compile the FPGA implementation! Specifically, the bitcraze lighthouse-fpga repository . It contains HLS code written in Scala along with a smattering of Verilog required to create a bitstream that can be loaded onto the Lattice ice40up5k FPGA. I'll leave the details about their implementation as an exercise to the reader (the README for that project is pretty in-depth). The part I was interested in was here . Before I went any further, I wanted to see if I could figure out the toolchain for this board to be sure that I knew how to make changes. Their instructions entail downloading, building, and installing a couple tools, so I followed this guide on a spare laptop I had to ensure that I wouldn't accidentally destroy my school laptop. But, when I typed make ... ERROR: Unable to find legal placement for all cells, design is probably at utilisation limit. Hm, well, there's instructions for generating a new timing seed in case you get timing errors, but no, this isn't a timing error. I believe this error was related to the design being too big to fit on the hardware. Describing an FPGA is out of scope for this blog (google it), but TL;DR, it's basically a chip with a whole bunch of LUTs that you can configure to act like any kind of logic circuit, as long as that circuit can translate to\u2014and fit on\u2014that array of LUTs. Around this point, I opened an issue to track my progress, and also to hopefully get someone's attention that their documentation doesn't Just Work. The first thing I tried was reverting back to the most recent tag . Maybe something was off about the design in the master branch, even though the CI was working, but surely this one would work? ... Info: Annotating ports with timing budgets for target frequency 24.00 MHz Info: Checksum: 0x7d970e13 Info: Device utilisation: Info: ICESTORM_LC: 4959/ 5280 93% Info: ICESTORM_RAM: 18/ 30 60% Info: SB_IO: 14/ 96 14% Info: SB_GB: 8/ 8 100% Info: ICESTORM_PLL: 1/ 1 100% Info: SB_WARMBOOT: 1/ 1 100% Info: ICESTORM_DSP: 0/ 8 0% Info: ICESTORM_HFOSC: 0/ 1 0% Info: ICESTORM_LFOSC: 0/ 1 0% Info: SB_I2C: 0/ 2 0% Info: SB_SPI: 0/ 2 0% Info: IO_I3C: 0/ 2 0% Info: SB_LEDDA_IP: 0/ 1 0% Info: SB_RGBA_DRV: 0/ 1 0% Info: ICESTORM_SPRAM: 0/ 4 0% Info: Placed 17 cells based on constraints. Info: Creating initial analytic placement for 4544 cells, random placement wirelen = 119963. Info: at initial placer iter 0, wirelen = 1157 Info: at initial placer iter 1, wirelen = 1036 Info: at initial placer iter 2, wirelen = 1001 Info: at initial placer iter 3, wirelen = 1096 Info: Running main analytical placer, max placement attempts per cell = 3126250. Info: at iteration #1, type ALL: wirelen solved = 1011, spread = 33666, legal = 54569; time = 4.92s Info: at iteration #2, type ALL: wirelen solved = 1872, spread = 25194, legal = 60314; time = 21.05s Info: at iteration #3, type ALL: wirelen solved = 3028, spread = 21014, legal = 57499; time = 9.17s ERROR: Unable to find legal placement for all cells, design is probably at utilisation limit. 10 warnings, 1 error make: *** [Makefile:20: lighthouse.asc] Error 255 OK, why didn't that work? What's the CI doing that I'm not? Run docker run --rm -v ${PWD}:/module bitcraze/fpga-builder ./tools/build/build Unable to find image 'bitcraze/fpga-builder:latest' locally latest: Pulling from bitcraze/fpga-builder Oh, there's a docker container. That wasn't mentioned in the README. I would actually later find out that there's a utility they have called toolbelt that I probably should have been using to build this. So, I pulled the docker container, and set up a copy of the repo I could pass in as a volume (since I wanted to keep the build artifacts). I also switched to Freedom, Computer Science House's gigantic 48-core compute server, in case I could speed up compilation more. podman run --rm -it \\ -v /scratch/wilnil/lighthouse-fpga/:/module/workdir:Z \\ --name bitcraze docker.io/bitcraze/fpga-builder After that, I cd 'ed into /module/workdir , ran make , and... ERROR: Max frequency for clock 'Core_clk': 47.03 MHz (FAIL at 48.00 MHz) ERROR: Max frequency for clock 'Slow_clk_$glb_clk': 21.16 MHz (FAIL at 24.00 MHz) OK! Progress! That's a timing error! This is expected :) So, now I have to run their search_seed.py just like the documentation says. Except, search_seed.py launched a Docker container. I don't have Docker, and I don't want Docker. However, I noticed that the V6 tag (I was still on master on Freedom) had an actual script, and not a Docker container. So I launched that on a single thread. The script, as far as I could tell, just tried to compile the design over and over again with a different seed, which, on a single core, would have taken hours . A quick tweak to the Python code, and I was doing 48 seeds at a time, which, on Freedom, took about 20 minutes to get through all 1000 seeds. After running through all 1000 seeds like 5 times, I had 3 seeds. None of them worked, though, and I don't really know why. Luckily, someone had replied to my issue and told me to try reducing a multiplier that had been set really high as a precaution. There's a function in the Scala HLS that is part of the pulse processing process (lol) that had that had a speed multiplier set to 4 to deal with a worst case scenario that would never actually happen. So, I set that multiplier to 1, and... Info: Max frequency for clock 'Core_clk': 51.58 MHz (PASS at 48.00 MHz) Info: Max frequency for clock 'Slow_clk_$glb_clk': 24.97 MHz (PASS at 24.00 MHz) Info: Max delay <async> -> posedge Slow_clk_$glb_clk: 4.19 ns Info: Max delay posedge Core_clk -> posedge Slow_clk_$glb_clk: 5.47 ns Info: Max delay posedge Slow_clk_$glb_clk -> <async> : 15.08 ns Info: Max delay posedge Slow_clk_$glb_clk -> posedge Core_clk : 17.20 ns Info: Slack histogram: Info: legend: * represents 30 endpoint(s) Info: + represents [1,30) endpoint(s) Info: [ 1447, 3297) |+ Info: [ 3297, 5147) |+ Info: [ 5147, 6997) |*+ Info: [ 6997, 8847) |*******************+ Info: [ 8847, 10697) |****+ Info: [ 10697, 12547) |***********+ Info: [ 12547, 14397) |*********+ Info: [ 14397, 16247) |*********+ Info: [ 16247, 18097) |*************+ Info: [ 18097, 19947) |**+ Info: [ 19947, 21797) |***+ Info: [ 21797, 23647) |*+ Info: [ 23647, 25497) |*+ Info: [ 25497, 27347) |*******+ Info: [ 27347, 29197) |********+ Info: [ 29197, 31047) |**********+ Info: [ 31047, 32897) |**********+ Info: [ 32897, 34747) |*****************+ Info: [ 34747, 36597) |*********************************************************+ Info: [ 36597, 38447) |************************************************************ 10 warnings, 0 errors Info: Program finished normally. python3 tools/update_bitstream_comment.py lighthouse.asc \"6\" icepack lighthouse.asc lighthouse.bin It passed! It doesn't compile all the time, though, and I'm not really sure why. So, I'll have to read up some more on their toolchains and whatnot, and probably install Docker and do things properly . But, the next step in the More Accessible Tracker journey is talking to the board! So, stay tuned for that. I'll need to rig up a voltage divider, a serial connection, and solder to this $120 board :E Creating a More Accessible Tracker Using the Bitcraze Lighthouse Positioning Deck 2023-02-24 Introduction When I began working on ClearGauntlets last year, it quickly became apparent that tracking was gonna be a bear of a project. For some reason, I figured that it was a solved problem. Somebody must have created a simple, easy-to-build device on the cheap to talk to Valve's cool lighthouses. And I was very wrong. This post will explain what I wanted to do, how wrong I was about how easy it would be to do so, and what my plan is going forward. TL;DR: I've purchased a Bitcraze Lighthouse Positioning Deck and want to make my own Lighthouse 2.0 trackers because I am curious to see if I can. The Problem VR tracking is, actually, an insanely complicated challenge. One that took AAA engineers decades to figure out and create a consumer product that didn't quite cost $1000. During the later half of the 2010's, hackers gained some traction on reverse engineering Valve/HTC's Lighthouse tech. From those efforts came libsurvive , an effort to fully unravel the stack, from the protocols that the lighthouses use to communicate with tracked devices, to the solving equations embedded in Valve's proprietary blobs. It's a truly incredible project that has been a huge inspiration to me on my short VR journey so far. However, these guys are focused on how to take Valve hardware and make it talk to their software. What I needed for the ClearGauntlets project was basically the opposite: Taking our hardware and getting it to talk to Valve software. ClearGauntlets is supposed to be a \"More Premium\u2122\" Haptic Glove solution. Our target kit price is $200, all included. We're a fork of the LucidVR project, whose Prototype 4.1 glove is supposed to cost somewhere around $60. However, they don't include in that price things like the batteries and trackers. That project relies on you either finding a way to mount your controller to your hand, or dropping a few hundred on something like Vive Trackers. I didn't like that, so I wanted to find a way to incorporate tracking into our gloves. Research We didn't have a lot of options. Because I only had an original, 2016-vintage HTC Vive, knew very little about VR, and yet was somehow the resident expert on the team, I decided to target the SteamVR ecosystem. I figured that it would be easy enough, and we went about googling. In a few weeks, we had only found two \"open source\" solutions for DIY tracked devices: The HiveTracker , and the Vive DIY Position Sensor . These looked like great options, until we realized that they were 7-ish years old. Not only that, but they only supported Lighthouse 1.0, and not the newer Lighthouse 2.0. Until we found these projects, I didn't really grasp the fact that there were two versions of Lighthouse tracking, and that if Lighthouse 1.0 was a Cessna prop plane, Lighthouse 2.0 was an F-18. 2.0 brought a slew of improvements and optimizations to SteamVR infrared tracking, and explaining the details and multitude of complications therein is out of scope here. What's important is that I very quickly realized that 2.0 tracking was not a solved problem for hackers, this entire problem is the kind of thing that people write about for their PhD thesis, and if someone was going to do it, it would be difficult and expensive. So we focused on Lighthouse 1.0 for now. It wasn't what we wanted, but we figured it would be good enough for the better-than-proof-of-concept gloves that we were trying to make. Lots of people\u2014myself included\u2014still had Lighthouse 1.0 gear, right? That was in October-ish. I kept reading. Eventually, sometime around December, I found the Bitcraze Lighthouse Positioning Deck , a board sold by Bitcraze designed to enable their open-source drone platform to be tracked with Lighthouse 2.0 technology. This was.... what I was looking for. All their source code, schematics, documentation, everything is available on their website for free. The board even has solder points for serial connections. I thought, \"What the hell!? How come someone hasn't hacked this thing already?\" I asked around on the LucidVR Discord, and the primary reasons, of course, are cost, and engineering effort. This board is $90, plus tax, plus shipping, comes out to $120. For that, you could get a Vive tracker that's plug-and-play, no fuss. It doesn't make sense for your average hacker to buy a \"development\" board for the price of a market-ready product when they are trying to make a pair of haptic gloves or whatever. The whole time I was researching, I had been made aware through a friend of mine the SteamVR HDK. Essentially, back in the mid 2010's, Valve had created a suite of hardware devices and software tools to help people make SteamVR compatible tracked devices. This would be perfect for this project, if only they still sold them. I've had a pretty tough time tracking down info, but to my understanding, the project is pretty much dead, unfortunately. A lot of links on their page are dead or broken . There is still a lot of info on the software on Steam's website and other places. Another project worth mentioning is Tundra Labs' SIP , but that has also been out of stock for months. Their datasheets do offer some nice inspiration. A Long Road Ahead I, however, am stupid. A fool, you might say. I hadn't yet realized that VR is actually pretty expensive . I wasn't ready to accept that my \"all-included\" gloves probably needed an extra $100 tacked on at least for an off-the-shelf tracking solution. However, I also realized that in order to take all of Bitcraze's IP and turn it from a drone product back into a SteamVR product would take a lot of time, effort, and money. So, I let the idea sit for a while. Until today. Today, my Bitcraze Lighthouse Positioning Deck arrived in the mail, all $120 of it. If you're on the #tracking-solutions channel on the LucidVR Discord, you'll probably have seen me raving about this project. I've decided that I need to take a step. I'm not really in this to play VR games. I'm in this because the tech is cool as hell. I've got this board, and I'm going to see if I can talk to it. Then, I'm going to see if I can program it. Then, I'm going to see if I can hack it. I'll be documenting my progress on this website. Probably on this page, so check back for regular updates. The Plan This will take months. It could take years. I don't want to give anybody the impression that I know what I am doing. I am an engineer by trade, yes, but I am such a noob to the entire VR space and tech stack. I have no idea why I'm even doing this other than, \"It's neat.\" I can almost guarantee that this will crash and burn. I'll hit some roadblock that will mean this project is dead. This is probably the most difficult, most expensive thing I've ever done. But I'll give it a go, so that Other People Don't Have To\u2122 . At least then we'll know. Here's the plan: Get it set up with my lighthouses (V1.0), and get data out of it onto my computer in literally any capacity. Talk to it over serial. Set up toolchain, build + flash firmware. Get it talking to SteamVR. Start Hacking it. Add sensors, try making my own device. Design some PCBs, print some trackers, etc. What is the end goal, you might (and definitely should) ask? Well, I just think that SteamVR Trackers are Too Damn Expensive, and I think it would be Swell to have a single tracker cost $60. Now that I've seen how difficult this field is, I think that would be reasonable. That would still mean that my $200 pricepoint for ClearGauntlets would be tight, if not impossible, since that'd be $120 for tracking alone for a pair where we originally wanted to spend no more than $50, but $25 for a tracker is almost certainly a pipe dream, at least in 2023. In summary, I want to take Bitcraze's design and source code and turn it into a Vive Tracker That You Can Build At Home. Order the PCB, order the parts, print a case, solder it up, flash it, and you're off. A DIY tracker for $60 designed for humans (not drones) to wear. That price has to include the PCB, every component on the PCB, the battery, the chassis, and any additional mounting hardware you'd need. Here's a list of everything off the top of my head that will be a P R O B L E M: The FPGA (and by extension Bitcraze's board) needs EXACTLY 3.0V. NOT 3.3V. The FPGA only appears to have enough I/O for 12 TS4231's (the chip connected to the photodiode that gets pulses from the Lighthouse) Everything is REALLY SMALL. Seriously I ordered this board and have it in hand and MY GOD IT IS SO SMALL Chip shortage could completely ruin my life. I've checked DigiKey and Mouser, and they seem to have stuff in stock, but I haven't actually bought anything yet because I am a coward. Bitcraze's FPGA code is written in Scala I don't know Scala I haven't a clue how I'm actually going to get data off the board yet Because the FPGA runs at a non-standard voltage, I'll probably need to order some kind of special cable to connect it to my PC. Secondly, the Lighthouse Positioning Deck does not have any kind of CPU onboard, only the FPGA, so I need a microcontroller and that'll probably be a lot of work. But other than that, this seems pretty easy. I've got the board here on my desk, and I'm looking at it right now... and I just realized that I'm writing this blog post to delay working on solving all of the above problems. So... guess I'm gonna go do that.","title":"More Accessible Tracker"},{"location":"blogs/mat/mat/#more-accessible-tracker","text":"In which a bozo attempts to do SteamVR tracking for cheap.","title":"More Accessible Tracker"},{"location":"blogs/mat/mat/#talking-i2c-and-a-base-for-uart-communication","text":"","title":"Talking I\u00b2C, and a base for UART communication"},{"location":"blogs/mat/mat/#2023-05-25","text":"It's been a minute. I was busy with school and the rest of this MSD project, but I'm finished with all that now, and have decided to spend the rest of the summer working on this project, so hopefully there will be at least a few updates in the next few months. ...is what I would have said on the 11th of May, if I hadn't had a bout of health issues over the last couple weeks. I'm back now, and working on the project again, and have some exciting updates:","title":"2023-05-25"},{"location":"blogs/mat/mat/#i2c","text":"The FPGA has two components: a bootloader, and firmware. This design makes the board \"unbrickable,\" since you can always flash new firmware if you mess something up. Anyway, this page details how that bootloader protocol works. Initially, I was trying to talk to it over UART 1 on the solder pads exposed, but that proved to be an exercise in futility. Instead, I shoved some jumper cables into the crazyflie expansion ports present on the deck, and set up I\u00b2C on an ESP32. I didn't bother regulating the voltage, and simply talk to it at 3.3V. To check if it worked, I tested the \"Version\" command, then I sent it the requisite boot commands, and he booted right up! The LEDs went from \"Red and Blue\" to \"EVERYTHING!\" There appear to be UART commands you can send to change those LEDs, but that's not really required for operation, since this thing is mostly stateless, and just vomits pulse data at you, I guess.","title":"I\u00b2C"},{"location":"blogs/mat/mat/#uart","text":"That's a nice little segue into the UART! Once the board is up, data spools in from UART0, once again located on those expansion pins. The protocol for that can be found documented in the lighthouse-fpga README , and you can find code for that in the Crazyflie firmware . The thing about this system that didn't really occur to me until I got in touch with Bitcraze about this project is that everything important happens onboard the crazyflie. This means that a large part of what the Vive Trackers do hasn't been implemented, that is, use 2.4GHz RF to talk to the PC so that it can do all of the solving. This is good news and bad news: Good news, I won't have to port much of their STM32 code to the ESP32, I basically just have to get the data and shunt it somewhere. Bad news: I have implement the shunting. Luckily, this seems to be a solved problem. Products like the Tundra Tracker SoC have a Nordic nRF52832 RF processor that deals with communication to the PC by way of their dongle, or perhaps a watchman dongle? (I don't know if this product would work with a Watchman dongle, but I imagine the tech is very similar). So, either I can do something fancy with the ESP32 (it has onboard 2.4GHz radios of some kind, maybe I can use those?), or I can bring in some Nordic chip to do that for me. Small issue: Cost. My digikey parts list is already up to $60 on its own, and that sucks! So, I'd like to figure out how to do all this with as little hardware as possible. But I'm getting ahead of myself. That's the next problem. Right now, I'm just trying to correctly interpret data from the deck (specifically, today, I'm learning about the sync pulses), and prepare it for... whatever's next (probably sending to the PC). After that, I'll probably need an IMU. I wrote this post as an update, since it's been so long. As I said, I wanted to send something out sooner, but I got sick. Hopefully in the next week or three, I'll have another update, and can begin working on the IMU and/or communication issues.","title":"UART"},{"location":"blogs/mat/mat/#code-please","text":"Sure! It's literally garbage right now, but you can find my repo here . All it does is boot up the board and vomit whatever it gets back on UART.","title":"Code, please?"},{"location":"blogs/mat/mat/#compiling-the-lighthouse-fpga-project","text":"","title":"Compiling the lighthouse-fpga project"},{"location":"blogs/mat/mat/#2023-03-07","text":"Hello again. I feel that this page is overdue for an update, so here's one: I've managed to compile the FPGA implementation! Specifically, the bitcraze lighthouse-fpga repository . It contains HLS code written in Scala along with a smattering of Verilog required to create a bitstream that can be loaded onto the Lattice ice40up5k FPGA. I'll leave the details about their implementation as an exercise to the reader (the README for that project is pretty in-depth). The part I was interested in was here . Before I went any further, I wanted to see if I could figure out the toolchain for this board to be sure that I knew how to make changes. Their instructions entail downloading, building, and installing a couple tools, so I followed this guide on a spare laptop I had to ensure that I wouldn't accidentally destroy my school laptop. But, when I typed make ... ERROR: Unable to find legal placement for all cells, design is probably at utilisation limit. Hm, well, there's instructions for generating a new timing seed in case you get timing errors, but no, this isn't a timing error. I believe this error was related to the design being too big to fit on the hardware. Describing an FPGA is out of scope for this blog (google it), but TL;DR, it's basically a chip with a whole bunch of LUTs that you can configure to act like any kind of logic circuit, as long as that circuit can translate to\u2014and fit on\u2014that array of LUTs. Around this point, I opened an issue to track my progress, and also to hopefully get someone's attention that their documentation doesn't Just Work. The first thing I tried was reverting back to the most recent tag . Maybe something was off about the design in the master branch, even though the CI was working, but surely this one would work? ... Info: Annotating ports with timing budgets for target frequency 24.00 MHz Info: Checksum: 0x7d970e13 Info: Device utilisation: Info: ICESTORM_LC: 4959/ 5280 93% Info: ICESTORM_RAM: 18/ 30 60% Info: SB_IO: 14/ 96 14% Info: SB_GB: 8/ 8 100% Info: ICESTORM_PLL: 1/ 1 100% Info: SB_WARMBOOT: 1/ 1 100% Info: ICESTORM_DSP: 0/ 8 0% Info: ICESTORM_HFOSC: 0/ 1 0% Info: ICESTORM_LFOSC: 0/ 1 0% Info: SB_I2C: 0/ 2 0% Info: SB_SPI: 0/ 2 0% Info: IO_I3C: 0/ 2 0% Info: SB_LEDDA_IP: 0/ 1 0% Info: SB_RGBA_DRV: 0/ 1 0% Info: ICESTORM_SPRAM: 0/ 4 0% Info: Placed 17 cells based on constraints. Info: Creating initial analytic placement for 4544 cells, random placement wirelen = 119963. Info: at initial placer iter 0, wirelen = 1157 Info: at initial placer iter 1, wirelen = 1036 Info: at initial placer iter 2, wirelen = 1001 Info: at initial placer iter 3, wirelen = 1096 Info: Running main analytical placer, max placement attempts per cell = 3126250. Info: at iteration #1, type ALL: wirelen solved = 1011, spread = 33666, legal = 54569; time = 4.92s Info: at iteration #2, type ALL: wirelen solved = 1872, spread = 25194, legal = 60314; time = 21.05s Info: at iteration #3, type ALL: wirelen solved = 3028, spread = 21014, legal = 57499; time = 9.17s ERROR: Unable to find legal placement for all cells, design is probably at utilisation limit. 10 warnings, 1 error make: *** [Makefile:20: lighthouse.asc] Error 255 OK, why didn't that work? What's the CI doing that I'm not? Run docker run --rm -v ${PWD}:/module bitcraze/fpga-builder ./tools/build/build Unable to find image 'bitcraze/fpga-builder:latest' locally latest: Pulling from bitcraze/fpga-builder Oh, there's a docker container. That wasn't mentioned in the README. I would actually later find out that there's a utility they have called toolbelt that I probably should have been using to build this. So, I pulled the docker container, and set up a copy of the repo I could pass in as a volume (since I wanted to keep the build artifacts). I also switched to Freedom, Computer Science House's gigantic 48-core compute server, in case I could speed up compilation more. podman run --rm -it \\ -v /scratch/wilnil/lighthouse-fpga/:/module/workdir:Z \\ --name bitcraze docker.io/bitcraze/fpga-builder After that, I cd 'ed into /module/workdir , ran make , and... ERROR: Max frequency for clock 'Core_clk': 47.03 MHz (FAIL at 48.00 MHz) ERROR: Max frequency for clock 'Slow_clk_$glb_clk': 21.16 MHz (FAIL at 24.00 MHz) OK! Progress! That's a timing error! This is expected :) So, now I have to run their search_seed.py just like the documentation says. Except, search_seed.py launched a Docker container. I don't have Docker, and I don't want Docker. However, I noticed that the V6 tag (I was still on master on Freedom) had an actual script, and not a Docker container. So I launched that on a single thread. The script, as far as I could tell, just tried to compile the design over and over again with a different seed, which, on a single core, would have taken hours . A quick tweak to the Python code, and I was doing 48 seeds at a time, which, on Freedom, took about 20 minutes to get through all 1000 seeds. After running through all 1000 seeds like 5 times, I had 3 seeds. None of them worked, though, and I don't really know why. Luckily, someone had replied to my issue and told me to try reducing a multiplier that had been set really high as a precaution. There's a function in the Scala HLS that is part of the pulse processing process (lol) that had that had a speed multiplier set to 4 to deal with a worst case scenario that would never actually happen. So, I set that multiplier to 1, and... Info: Max frequency for clock 'Core_clk': 51.58 MHz (PASS at 48.00 MHz) Info: Max frequency for clock 'Slow_clk_$glb_clk': 24.97 MHz (PASS at 24.00 MHz) Info: Max delay <async> -> posedge Slow_clk_$glb_clk: 4.19 ns Info: Max delay posedge Core_clk -> posedge Slow_clk_$glb_clk: 5.47 ns Info: Max delay posedge Slow_clk_$glb_clk -> <async> : 15.08 ns Info: Max delay posedge Slow_clk_$glb_clk -> posedge Core_clk : 17.20 ns Info: Slack histogram: Info: legend: * represents 30 endpoint(s) Info: + represents [1,30) endpoint(s) Info: [ 1447, 3297) |+ Info: [ 3297, 5147) |+ Info: [ 5147, 6997) |*+ Info: [ 6997, 8847) |*******************+ Info: [ 8847, 10697) |****+ Info: [ 10697, 12547) |***********+ Info: [ 12547, 14397) |*********+ Info: [ 14397, 16247) |*********+ Info: [ 16247, 18097) |*************+ Info: [ 18097, 19947) |**+ Info: [ 19947, 21797) |***+ Info: [ 21797, 23647) |*+ Info: [ 23647, 25497) |*+ Info: [ 25497, 27347) |*******+ Info: [ 27347, 29197) |********+ Info: [ 29197, 31047) |**********+ Info: [ 31047, 32897) |**********+ Info: [ 32897, 34747) |*****************+ Info: [ 34747, 36597) |*********************************************************+ Info: [ 36597, 38447) |************************************************************ 10 warnings, 0 errors Info: Program finished normally. python3 tools/update_bitstream_comment.py lighthouse.asc \"6\" icepack lighthouse.asc lighthouse.bin It passed! It doesn't compile all the time, though, and I'm not really sure why. So, I'll have to read up some more on their toolchains and whatnot, and probably install Docker and do things properly . But, the next step in the More Accessible Tracker journey is talking to the board! So, stay tuned for that. I'll need to rig up a voltage divider, a serial connection, and solder to this $120 board :E","title":"2023-03-07"},{"location":"blogs/mat/mat/#creating-a-more-accessible-tracker-using-the-bitcraze-lighthouse-positioning-deck","text":"","title":"Creating a More Accessible Tracker Using the Bitcraze Lighthouse Positioning Deck"},{"location":"blogs/mat/mat/#2023-02-24","text":"","title":"2023-02-24"},{"location":"blogs/mat/mat/#introduction","text":"When I began working on ClearGauntlets last year, it quickly became apparent that tracking was gonna be a bear of a project. For some reason, I figured that it was a solved problem. Somebody must have created a simple, easy-to-build device on the cheap to talk to Valve's cool lighthouses. And I was very wrong. This post will explain what I wanted to do, how wrong I was about how easy it would be to do so, and what my plan is going forward. TL;DR: I've purchased a Bitcraze Lighthouse Positioning Deck and want to make my own Lighthouse 2.0 trackers because I am curious to see if I can.","title":"Introduction"},{"location":"blogs/mat/mat/#the-problem","text":"VR tracking is, actually, an insanely complicated challenge. One that took AAA engineers decades to figure out and create a consumer product that didn't quite cost $1000. During the later half of the 2010's, hackers gained some traction on reverse engineering Valve/HTC's Lighthouse tech. From those efforts came libsurvive , an effort to fully unravel the stack, from the protocols that the lighthouses use to communicate with tracked devices, to the solving equations embedded in Valve's proprietary blobs. It's a truly incredible project that has been a huge inspiration to me on my short VR journey so far. However, these guys are focused on how to take Valve hardware and make it talk to their software. What I needed for the ClearGauntlets project was basically the opposite: Taking our hardware and getting it to talk to Valve software. ClearGauntlets is supposed to be a \"More Premium\u2122\" Haptic Glove solution. Our target kit price is $200, all included. We're a fork of the LucidVR project, whose Prototype 4.1 glove is supposed to cost somewhere around $60. However, they don't include in that price things like the batteries and trackers. That project relies on you either finding a way to mount your controller to your hand, or dropping a few hundred on something like Vive Trackers. I didn't like that, so I wanted to find a way to incorporate tracking into our gloves.","title":"The Problem"},{"location":"blogs/mat/mat/#research","text":"We didn't have a lot of options. Because I only had an original, 2016-vintage HTC Vive, knew very little about VR, and yet was somehow the resident expert on the team, I decided to target the SteamVR ecosystem. I figured that it would be easy enough, and we went about googling. In a few weeks, we had only found two \"open source\" solutions for DIY tracked devices: The HiveTracker , and the Vive DIY Position Sensor . These looked like great options, until we realized that they were 7-ish years old. Not only that, but they only supported Lighthouse 1.0, and not the newer Lighthouse 2.0. Until we found these projects, I didn't really grasp the fact that there were two versions of Lighthouse tracking, and that if Lighthouse 1.0 was a Cessna prop plane, Lighthouse 2.0 was an F-18. 2.0 brought a slew of improvements and optimizations to SteamVR infrared tracking, and explaining the details and multitude of complications therein is out of scope here. What's important is that I very quickly realized that 2.0 tracking was not a solved problem for hackers, this entire problem is the kind of thing that people write about for their PhD thesis, and if someone was going to do it, it would be difficult and expensive. So we focused on Lighthouse 1.0 for now. It wasn't what we wanted, but we figured it would be good enough for the better-than-proof-of-concept gloves that we were trying to make. Lots of people\u2014myself included\u2014still had Lighthouse 1.0 gear, right? That was in October-ish. I kept reading. Eventually, sometime around December, I found the Bitcraze Lighthouse Positioning Deck , a board sold by Bitcraze designed to enable their open-source drone platform to be tracked with Lighthouse 2.0 technology. This was.... what I was looking for. All their source code, schematics, documentation, everything is available on their website for free. The board even has solder points for serial connections. I thought, \"What the hell!? How come someone hasn't hacked this thing already?\" I asked around on the LucidVR Discord, and the primary reasons, of course, are cost, and engineering effort. This board is $90, plus tax, plus shipping, comes out to $120. For that, you could get a Vive tracker that's plug-and-play, no fuss. It doesn't make sense for your average hacker to buy a \"development\" board for the price of a market-ready product when they are trying to make a pair of haptic gloves or whatever. The whole time I was researching, I had been made aware through a friend of mine the SteamVR HDK. Essentially, back in the mid 2010's, Valve had created a suite of hardware devices and software tools to help people make SteamVR compatible tracked devices. This would be perfect for this project, if only they still sold them. I've had a pretty tough time tracking down info, but to my understanding, the project is pretty much dead, unfortunately. A lot of links on their page are dead or broken . There is still a lot of info on the software on Steam's website and other places. Another project worth mentioning is Tundra Labs' SIP , but that has also been out of stock for months. Their datasheets do offer some nice inspiration.","title":"Research"},{"location":"blogs/mat/mat/#a-long-road-ahead","text":"I, however, am stupid. A fool, you might say. I hadn't yet realized that VR is actually pretty expensive . I wasn't ready to accept that my \"all-included\" gloves probably needed an extra $100 tacked on at least for an off-the-shelf tracking solution. However, I also realized that in order to take all of Bitcraze's IP and turn it from a drone product back into a SteamVR product would take a lot of time, effort, and money. So, I let the idea sit for a while. Until today. Today, my Bitcraze Lighthouse Positioning Deck arrived in the mail, all $120 of it. If you're on the #tracking-solutions channel on the LucidVR Discord, you'll probably have seen me raving about this project. I've decided that I need to take a step. I'm not really in this to play VR games. I'm in this because the tech is cool as hell. I've got this board, and I'm going to see if I can talk to it. Then, I'm going to see if I can program it. Then, I'm going to see if I can hack it. I'll be documenting my progress on this website. Probably on this page, so check back for regular updates.","title":"A Long Road Ahead"},{"location":"blogs/mat/mat/#the-plan","text":"This will take months. It could take years. I don't want to give anybody the impression that I know what I am doing. I am an engineer by trade, yes, but I am such a noob to the entire VR space and tech stack. I have no idea why I'm even doing this other than, \"It's neat.\" I can almost guarantee that this will crash and burn. I'll hit some roadblock that will mean this project is dead. This is probably the most difficult, most expensive thing I've ever done. But I'll give it a go, so that Other People Don't Have To\u2122 . At least then we'll know. Here's the plan: Get it set up with my lighthouses (V1.0), and get data out of it onto my computer in literally any capacity. Talk to it over serial. Set up toolchain, build + flash firmware. Get it talking to SteamVR. Start Hacking it. Add sensors, try making my own device. Design some PCBs, print some trackers, etc. What is the end goal, you might (and definitely should) ask? Well, I just think that SteamVR Trackers are Too Damn Expensive, and I think it would be Swell to have a single tracker cost $60. Now that I've seen how difficult this field is, I think that would be reasonable. That would still mean that my $200 pricepoint for ClearGauntlets would be tight, if not impossible, since that'd be $120 for tracking alone for a pair where we originally wanted to spend no more than $50, but $25 for a tracker is almost certainly a pipe dream, at least in 2023. In summary, I want to take Bitcraze's design and source code and turn it into a Vive Tracker That You Can Build At Home. Order the PCB, order the parts, print a case, solder it up, flash it, and you're off. A DIY tracker for $60 designed for humans (not drones) to wear. That price has to include the PCB, every component on the PCB, the battery, the chassis, and any additional mounting hardware you'd need. Here's a list of everything off the top of my head that will be a P R O B L E M: The FPGA (and by extension Bitcraze's board) needs EXACTLY 3.0V. NOT 3.3V. The FPGA only appears to have enough I/O for 12 TS4231's (the chip connected to the photodiode that gets pulses from the Lighthouse) Everything is REALLY SMALL. Seriously I ordered this board and have it in hand and MY GOD IT IS SO SMALL Chip shortage could completely ruin my life. I've checked DigiKey and Mouser, and they seem to have stuff in stock, but I haven't actually bought anything yet because I am a coward. Bitcraze's FPGA code is written in Scala I don't know Scala I haven't a clue how I'm actually going to get data off the board yet Because the FPGA runs at a non-standard voltage, I'll probably need to order some kind of special cable to connect it to my PC. Secondly, the Lighthouse Positioning Deck does not have any kind of CPU onboard, only the FPGA, so I need a microcontroller and that'll probably be a lot of work. But other than that, this seems pretty easy. I've got the board here on my desk, and I'm looking at it right now... and I just realized that I'm writing this blog post to delay working on solving all of the above problems. So... guess I'm gonna go do that.","title":"The Plan"},{"location":"blogs/willard/2023-02-21/","text":"ClearGauntlets Power (Mis)management 2023-02-21 Update: 2023-05-02 There have been developments with the power module that make this information obsolete. The power module referenced here is still insufficient for our design. Refer to information in the \"Projects\" tab (not yet written) for advice on power systems. Last week, Tucker finished building the ClearGauntlet 1.0, and handed it off to me to get it wired up and tested out before our demo. Having finished assembling Rev B of our PCB, all that was left to do was solder short, three-pin IDE cables to each potentiometer, crimp Dupont connectors to the ends, and plug everything in. Unlike the previous semester's prototypes, this glove was \"complete.\" It had five fingers, and five servos, instead of two. Initially, testing was done with the latest revision of the LucidVR firmware, 5V JST connector plugged into the wall (another teammate had the power module at the time), and serial port plugged into the PC. This setup appeared to be functional. All the fingers were responding, despite some issues with sticky reels and an overly-sensitive middle finger potentiometer. After spending some time tweaking the strength of the force feedback, the board was re-configured to work over Bluetooth. The serial cable was disconnected and the driver was configured for wireless operation, leaving just the 5V/2.3A wall wart to supply power. Problems crop up almost immediately. There were several hints as to what was wrong: When using the UI to extend or retract all servos, the first command would go through, and the servos would move a small amount, then die, and be unresponsive to further commands. Sometimes, the servos would get stuck jittering. In-game, finger tracking would work flawlessly, until grabbing something. The fingers would then freeze in place for a time, then start tracking again. The next time a hand is moved, the game would freeze while Visual Studio would break on a Read access violation. When firing all five servos at once (either by using the UI or moving towards an object in game) the status LED on the ESP32 would dim or flicker, indicating a brownout. All issues would vanish when 2-3 servos were disconnected from the board, reducing the momentary peak current of the glove. Aside from the power management issues, there were some tweaks that needed to be made to the Bluetooth communication code, graciously completed by @danwillm#8254 on Discord. These mostly concerned issues with latency and connection bootstrapping. To solve the power management issues, testing was conducted with a variety of power delivery methods. It was concluded that a large, 5V/3A power source was required to keep the microcontroller fed during high power draw while the servos fired. Additionally, 2000\u00b5F electrolytic capacitors were added across the Vin and 3V3 pins of the ESP32, but this does not appear to have an appreciable effect on the survivability of the microcontroller. 100nF ceramic capacitors were also added across the power inputs of each servo. Takeaways ClearGauntlets requires at least a 5V/3A supply to power itself. Thus, a larger, two-cell version of the power module will be used from now on. Rev C of the ClearGauntlets board will require additional power circuitry such as load capacitors, and perhaps a separation of the power input for the ESP32. Links Twidge's description of capacitors \"Brownouts\" thread on LucidVR Discord \"Bluetooth socket error\" on LucidVR Discord","title":"2023 02 21"},{"location":"blogs/willard/2023-02-21/#cleargauntlets-power-mismanagement","text":"","title":"ClearGauntlets Power (Mis)management"},{"location":"blogs/willard/2023-02-21/#2023-02-21","text":"","title":"2023-02-21"},{"location":"blogs/willard/2023-02-21/#update-2023-05-02","text":"There have been developments with the power module that make this information obsolete. The power module referenced here is still insufficient for our design. Refer to information in the \"Projects\" tab (not yet written) for advice on power systems. Last week, Tucker finished building the ClearGauntlet 1.0, and handed it off to me to get it wired up and tested out before our demo. Having finished assembling Rev B of our PCB, all that was left to do was solder short, three-pin IDE cables to each potentiometer, crimp Dupont connectors to the ends, and plug everything in. Unlike the previous semester's prototypes, this glove was \"complete.\" It had five fingers, and five servos, instead of two. Initially, testing was done with the latest revision of the LucidVR firmware, 5V JST connector plugged into the wall (another teammate had the power module at the time), and serial port plugged into the PC. This setup appeared to be functional. All the fingers were responding, despite some issues with sticky reels and an overly-sensitive middle finger potentiometer. After spending some time tweaking the strength of the force feedback, the board was re-configured to work over Bluetooth. The serial cable was disconnected and the driver was configured for wireless operation, leaving just the 5V/2.3A wall wart to supply power. Problems crop up almost immediately. There were several hints as to what was wrong: When using the UI to extend or retract all servos, the first command would go through, and the servos would move a small amount, then die, and be unresponsive to further commands. Sometimes, the servos would get stuck jittering. In-game, finger tracking would work flawlessly, until grabbing something. The fingers would then freeze in place for a time, then start tracking again. The next time a hand is moved, the game would freeze while Visual Studio would break on a Read access violation. When firing all five servos at once (either by using the UI or moving towards an object in game) the status LED on the ESP32 would dim or flicker, indicating a brownout. All issues would vanish when 2-3 servos were disconnected from the board, reducing the momentary peak current of the glove. Aside from the power management issues, there were some tweaks that needed to be made to the Bluetooth communication code, graciously completed by @danwillm#8254 on Discord. These mostly concerned issues with latency and connection bootstrapping. To solve the power management issues, testing was conducted with a variety of power delivery methods. It was concluded that a large, 5V/3A power source was required to keep the microcontroller fed during high power draw while the servos fired. Additionally, 2000\u00b5F electrolytic capacitors were added across the Vin and 3V3 pins of the ESP32, but this does not appear to have an appreciable effect on the survivability of the microcontroller. 100nF ceramic capacitors were also added across the power inputs of each servo. Takeaways ClearGauntlets requires at least a 5V/3A supply to power itself. Thus, a larger, two-cell version of the power module will be used from now on. Rev C of the ClearGauntlets board will require additional power circuitry such as load capacitors, and perhaps a separation of the power input for the ESP32. Links Twidge's description of capacitors \"Brownouts\" thread on LucidVR Discord \"Bluetooth socket error\" on LucidVR Discord","title":"Update: 2023-05-02"},{"location":"docs/electrical/","text":"ClearGauntlet-PCB-rev B PCB - Schematics Design for VR Gloves A breakout board for ClearGauntlets, aimed at improving cable management and minifying electronics of VR Gloves. Specs The board has the following I/O: 1 ESP 32 V1 10 potentiometers, each requires 1 3.3V pin, 1 GND, 1 Analog pin. 5 servo motors, each requires 1 5V pin, 1 GND, 1 Analog pin. 2 pushed bottons 1 joystick (5 pins) 1 power JST connection (3 pins: 1 5V and 2 GND) Pin details Assembly To assemble the board, you'll need - 30 pins Female Dupont Connectors, 2.54mm pitch (2x 15-pin). This is for holding the ESP-32 - 15 x 3 pins Male Dupont Connectors, 2.54mm pitch, for connecting potentiomers, servos) - 2 x 2 pin Male Dupont for push buttons and 5 pin Male Dupont for Joystick - 1 ESP32 It's all just through-hole soldering, so it goes pretty quick once you have the parts. Use the CAD renders as a guide. You will also probably want to create a 2-pin 5V USB cable like this one: It's just power, and ground, and goes into the 5V/GND JST connector next to the ESP32. You'll also need to bodge that 5V in pin to the Vin pin that goes to the ESP32 Demo Picture Plain PCB Assembled PCB ClearGauntlet - Joystick PCB Joystick PCB - Schematics Design for interfacing between Joycon's joystick and main PCB. Motivation : To allow for joystick control in games that support/require it, we're kludging a Nintendo Switch Joystick onto our glove. Since the flex cable is very short and flimsy, we want to create a small PCB board to hold, and connect pins to the main PCB more reliably. Components Joystick This joystick is the 3rd party replacement for the joycon. Schematics The measurement of the joystick in mm: Adapter We need a 5-pin (0.5mm spaced) adaptor to connect on the board and split the pins to the standard dupont spacing (2.56 mm). This model can be found on Mouser. PCB 3D model Assembly The joystick will be mounted on the backside of the PCB either by through holes or hot glued it directly. Then, the flex cable will connect to the adaptor. A horizontal 5-pin male dupont will be place at the J2 and run a wire to the main PCB. The idea is to make PCB-joystick as a module which will be placed on the side of the index finger.# CG Proto 2 Wiring Guide Assembling the PCB The PCB assembly should be pretty straightforward. It is simply a breakout board for many of the ESP32\u2019s connections. You will need fifteen three-pin male dupont connectors, two fifteen-pin female dupont connectors, one 2x4-pin female dupont connector, a 1000uF capacitor, a 680ohm resistor, and a four-pin male dupont connector with the second and fourth pins cut off. Wiring the finger modules You can get started on wiring up your potentiometers once you\u2019ve reached this stage of printing and assembly. Figure 1: Tools required for finger module wiring For each hand, you\u2019ll need ten three-pin dupont connectors, a length of ribbon cable (I like to use salvaged IDE cables), a crimping tool, and a soldering kit. Cut twenty three-pin cables to the lengths found in Table 1. Crimp them with three pin female dupont connectors. Figure 2: Cables cut to length Table 1: Rotation of spools and length of cable Finger Spool Rotation Curl Cable Length Splay Cable Length Right Thumb Clockwise 8\u201d 8\u201d Right Pointer Counterclockwise 7\u201d 7\u201d Right Middle Counterclockwise 6\u201d 6\u201d Right Ring Clockwise 5\u201d 5\u201d Right Pinky Clockwise 6\u201d 6\u201d Left Thumb Counterclockwise 8\u201d 8\u201d Left Pointer Clockwise 8\u201d 8\u201d Left Middle Clockwise 6\u201d 6\u201d Left Ring Counterclockwise 5\u201d 6\u201d Left Pinky Counterclockwise 5\u201d 6\u201d You will have to cross one of the wires, since the middle pin of the breakout PCB is the VCC pin and the middle pin of the potentiometer is the signal pin. The recommended pinout of the cables is shown below. Figure 3: Soldering guide for module cables On the left hand, the pair of wires farthest from your wrist should be crossed, and on the right, the pair of wires closest to your wrist should be crossed. This ensures a consistent pinout across the entire pair, and will make it easier to configure in software later. Both the curl and splay potentiometers should be soldered this way. (Because the spin direction of the potentiometers is reversed on the pointer and middle finger, the firmware will need to be configured to reverse the measured value later) My technique is this: Tin the ends of the wire, then heavily tin the end of the potentiometer. Use a helping hand to hold the module, then with your hands, hold the wires and soldering iron. Solder each wire one at a time, and give the module a chance to cool down between each pin soldering to prevent burning out the potentiometer. When you are finished, you\u2019ll have something that looks like this: Figure 4: Soldered finger modules with un-managed cables Organizing the wires is a little\u2026 chaotic. I usually just try to corral them together as much as possible towards the pinky, plug \u2018em in, then try to zip tie them in place. I\u2019m still working on the cable lengths and am hoping to add more cable channels and perhaps update the PCB to alternate curl/splay to reduce the amount of weird overlap we have. But, when you\u2019re finished, you should have something that looks like this: Figure 5: Completed Finger Tracking Module Calibrating and Installing the Servos TODO","title":"Electrical"},{"location":"docs/electrical/#cleargauntlet-pcb-rev-b","text":"PCB - Schematics Design for VR Gloves A breakout board for ClearGauntlets, aimed at improving cable management and minifying electronics of VR Gloves.","title":"ClearGauntlet-PCB-rev B"},{"location":"docs/electrical/#specs","text":"The board has the following I/O: 1 ESP 32 V1 10 potentiometers, each requires 1 3.3V pin, 1 GND, 1 Analog pin. 5 servo motors, each requires 1 5V pin, 1 GND, 1 Analog pin. 2 pushed bottons 1 joystick (5 pins) 1 power JST connection (3 pins: 1 5V and 2 GND)","title":"Specs"},{"location":"docs/electrical/#pin-details","text":"","title":"Pin details"},{"location":"docs/electrical/#assembly","text":"To assemble the board, you'll need - 30 pins Female Dupont Connectors, 2.54mm pitch (2x 15-pin). This is for holding the ESP-32 - 15 x 3 pins Male Dupont Connectors, 2.54mm pitch, for connecting potentiomers, servos) - 2 x 2 pin Male Dupont for push buttons and 5 pin Male Dupont for Joystick - 1 ESP32 It's all just through-hole soldering, so it goes pretty quick once you have the parts. Use the CAD renders as a guide. You will also probably want to create a 2-pin 5V USB cable like this one: It's just power, and ground, and goes into the 5V/GND JST connector next to the ESP32. You'll also need to bodge that 5V in pin to the Vin pin that goes to the ESP32","title":"Assembly"},{"location":"docs/electrical/#demo-picture","text":"","title":"Demo Picture"},{"location":"docs/electrical/#plain-pcb","text":"","title":"Plain PCB"},{"location":"docs/electrical/#assembled-pcb","text":"","title":"Assembled PCB"},{"location":"docs/electrical/#cleargauntlet-joystick-pcb","text":"Joystick PCB - Schematics Design for interfacing between Joycon's joystick and main PCB. Motivation : To allow for joystick control in games that support/require it, we're kludging a Nintendo Switch Joystick onto our glove. Since the flex cable is very short and flimsy, we want to create a small PCB board to hold, and connect pins to the main PCB more reliably.","title":"ClearGauntlet - Joystick PCB"},{"location":"docs/electrical/#components","text":"","title":"Components"},{"location":"docs/electrical/#joystick","text":"This joystick is the 3rd party replacement for the joycon. Schematics The measurement of the joystick in mm:","title":"Joystick"},{"location":"docs/electrical/#adapter","text":"We need a 5-pin (0.5mm spaced) adaptor to connect on the board and split the pins to the standard dupont spacing (2.56 mm). This model can be found on Mouser.","title":"Adapter"},{"location":"docs/electrical/#pcb","text":"3D model","title":"PCB"},{"location":"docs/electrical/#assembly_1","text":"The joystick will be mounted on the backside of the PCB either by through holes or hot glued it directly. Then, the flex cable will connect to the adaptor. A horizontal 5-pin male dupont will be place at the J2 and run a wire to the main PCB. The idea is to make PCB-joystick as a module which will be placed on the side of the index finger.# CG Proto 2 Wiring Guide","title":"Assembly"},{"location":"docs/electrical/#assembling-the-pcb","text":"The PCB assembly should be pretty straightforward. It is simply a breakout board for many of the ESP32\u2019s connections. You will need fifteen three-pin male dupont connectors, two fifteen-pin female dupont connectors, one 2x4-pin female dupont connector, a 1000uF capacitor, a 680ohm resistor, and a four-pin male dupont connector with the second and fourth pins cut off.","title":"Assembling the PCB"},{"location":"docs/electrical/#wiring-the-finger-modules","text":"You can get started on wiring up your potentiometers once you\u2019ve reached this stage of printing and assembly. Figure 1: Tools required for finger module wiring For each hand, you\u2019ll need ten three-pin dupont connectors, a length of ribbon cable (I like to use salvaged IDE cables), a crimping tool, and a soldering kit. Cut twenty three-pin cables to the lengths found in Table 1. Crimp them with three pin female dupont connectors. Figure 2: Cables cut to length Table 1: Rotation of spools and length of cable Finger Spool Rotation Curl Cable Length Splay Cable Length Right Thumb Clockwise 8\u201d 8\u201d Right Pointer Counterclockwise 7\u201d 7\u201d Right Middle Counterclockwise 6\u201d 6\u201d Right Ring Clockwise 5\u201d 5\u201d Right Pinky Clockwise 6\u201d 6\u201d Left Thumb Counterclockwise 8\u201d 8\u201d Left Pointer Clockwise 8\u201d 8\u201d Left Middle Clockwise 6\u201d 6\u201d Left Ring Counterclockwise 5\u201d 6\u201d Left Pinky Counterclockwise 5\u201d 6\u201d You will have to cross one of the wires, since the middle pin of the breakout PCB is the VCC pin and the middle pin of the potentiometer is the signal pin. The recommended pinout of the cables is shown below. Figure 3: Soldering guide for module cables On the left hand, the pair of wires farthest from your wrist should be crossed, and on the right, the pair of wires closest to your wrist should be crossed. This ensures a consistent pinout across the entire pair, and will make it easier to configure in software later. Both the curl and splay potentiometers should be soldered this way. (Because the spin direction of the potentiometers is reversed on the pointer and middle finger, the firmware will need to be configured to reverse the measured value later) My technique is this: Tin the ends of the wire, then heavily tin the end of the potentiometer. Use a helping hand to hold the module, then with your hands, hold the wires and soldering iron. Solder each wire one at a time, and give the module a chance to cool down between each pin soldering to prevent burning out the potentiometer. When you are finished, you\u2019ll have something that looks like this: Figure 4: Soldered finger modules with un-managed cables Organizing the wires is a little\u2026 chaotic. I usually just try to corral them together as much as possible towards the pinky, plug \u2018em in, then try to zip tie them in place. I\u2019m still working on the cable lengths and am hoping to add more cable channels and perhaps update the PCB to alternate curl/splay to reduce the amount of weird overlap we have. But, when you\u2019re finished, you should have something that looks like this: Figure 5: Completed Finger Tracking Module","title":"Wiring the finger modules"},{"location":"docs/electrical/#calibrating-and-installing-the-servos","text":"TODO","title":"Calibrating and Installing the Servos"},{"location":"docs/mechanical/","text":"Mechanical We are a fork of LucidVR's Prototype 4. Hopefully, our assembly is more straightforward, thanks to our simplified spool design. Below is the documentaiton to assemble a single finger module. Follow it five times per hand. Mechanical Assembly Guide This guide details the full process of assembling the mechanical system for ClearGauntlets. This process will require all the 3D printed components, all the potentiometers, and the badge reels. Start assembly at the finger module level. Insert the first potentiometer into the center slot. Put the nut in the spool 1 part. It should be a tight fit. Screw the spool 1 down onto the potentiometer. We need the two holes to be aligned on either side of the front post. Most often, they won\u2019t be aligned initially. At this point, take note of which way part of the post is facing the front of the module. Use a sharpie to mark the corner of the hex nut which pointed to the front of the module Remove the nut and reinster with the marked corner now oriented in between the two holes Screw the spool 1 back onto the module base Grab the spool 2 part and a badge reel Cut the end of the badge reel string off Use a pair of pliers or wire cutters to break open the badge reel, crushing the opening worked well on my badge reels Extract the spring and the string from the badge reel. You can throw the rest out. Cut spring to a little under 10 inches, no need to be precise Put a little bend in the cut end, it should only be maybe 2-3mm long, this will hold it in the potentiometer slot without slipping out. Before winding the spring make sure the potentiometer is turned fully in one direction. This should be clockwise if the module you are making is going to have the string coming out on the right side of the module. It will be counterclockwise if the string comes out on the left side. This guide is showing a module where the string comes out to the right, iIf you are assembling a module where the string comes out on the left side, the direction of all winding in this guide should be reversed. The modules where the string will come out to the right include Right Hand (RH) pointer, and middle, and LH ring, pinky, and thumb. The modules where the string will come out to the left include RH ring, pinky, and thumb, and LH pointer and middle. Starting with the flanged end, insert it through the sqaure hole on the left, you\u2019ll need to come in at an angle. You want the little divet to be passing through the square hole, the short end inside the inner area, and the rest of the spring coming out. Start winding the spring counterclockwise, you\u2019ll move it to the inner area right away, this motion should cause the flanged end to be pushed against the side wall as shown here. As you are winding, you\u2019ll also be guiding it down in line with the flanged end. You\u2019ll want to be holding it down with one thumb, while you use the other hand to move the free end. The next three images show how I hold down the spooled spring, guide the free end around, and switch thumbs as I continue to guide in the free end of the spring. Once you get the rhythm of it, it isn\u2019t too difficult. Once you reach the end of the spring, use a pair of needle nose pliers to grab the very end before the bend, curve it around a little more and place it in the slot of the potentiometer. The spring might need to stretch a little bit in order to reach the slot, that\u2019s okay and it will put a little tension on the potentiometer in it\u2019s resting position, which is good. It should look like this. Use your pliers to push the spring down into place if needed. We want it to be nice, neat, and all in line with itself, not coming up and down at different spots. Thread the string though the hole in the upper spool. Start winding to the right (clockwise if you look from below, counterclockwise if you look from above). Try to wind it fairly tight. I like to just wind up until I can\u2019t wind without stacking it on itself (usually 5 or so winds). This will keep it flat against the spool. Thread the string though the hole in the lower spool. Bring the upper spool down into place, while keeping some tension on the end of the string. Just shoving it in will cause the string to get all fucked up in there. Keep tension as you push the upper spool down onto the potentiometer Insert the other potentiometer, and tighten it into place with the hex nut Position the potentiometer shaft so that it is halfway through its rotation range. Than press the splay linkage onto the potentiometer shaft. Assemble all of the modules in this fashion. Now on to the larger assembly. Cut two 12\u201d strips of omni tape for each glove. May be shorter or longer depending on hand size. Fasten the straps to the outside edge of the baseplate as shown. Either sew or glue this end to itself to create a tight anchor point for the straps. Running the straps through the other slots on the baseplate, fasten the baseplate to the glove on your hand. Find a position that feels comfortable on your hand and where you think the modules will be positioned in line with their respective fingers. Once you find this potion, use a hot glue gun to glue the baseplate down to the glove in that position. I prefer to be wearing the glove when I do this, so I can feel and adjust the position as I am gluing. Once that is dry, put the modules on the baseplate. They slide on and then the retainers snap into the baseplate to keep them in place. Find a comfortable position for the end of the splay node and glue it to the glove using hot glue. You should be able to comfortably open/close your hand fully. You should also be able to splay your fingers with the linkage naturally following, this can be trickiest for the thumb. It should also be generally around the first finger knuckle so it can guide the string at that point. Do this for every finger. Glue the finger rings onto each finger. They should be past the last finger knuckle so the wide portion engages with the finger pad. They shouldn\u2019t be on the center of your finger pad as you still want to be able to feel and use your fingers. The adjacent finger rings should naturally stagger with the lengths of your fingers, if they are even with each other then they may bump into each other which will be more noticeable when using the final product. Next use a needle threading tool to thread the string from each module through the two holes on the splay node, and the lower hole on the finger ring. Thread the string back through the top hole of the finger ring. Pull the string taut and tie a double overhand knot at the finger ring. Start by passing the end of the string under the thread running in between the splay node and finger ring. Pass the end of the string through the loop created by the previous step. Then pull tight. Repeat to create a second knot on top. Before pulling the knot tight, make sure the main line is tight. The fingers on the glove should be in the fully extended position, then pull the string coming out of the top hole on the finger ring right before tightening the knot. This is important so that the string is the right length so that the zero position of the reel is at full extension. You may need to adjust the tightness in this step.","title":"Mechanical"},{"location":"docs/mechanical/#mechanical","text":"We are a fork of LucidVR's Prototype 4. Hopefully, our assembly is more straightforward, thanks to our simplified spool design. Below is the documentaiton to assemble a single finger module. Follow it five times per hand.","title":"Mechanical"},{"location":"docs/mechanical/#mechanical-assembly-guide","text":"This guide details the full process of assembling the mechanical system for ClearGauntlets. This process will require all the 3D printed components, all the potentiometers, and the badge reels. Start assembly at the finger module level. Insert the first potentiometer into the center slot. Put the nut in the spool 1 part. It should be a tight fit. Screw the spool 1 down onto the potentiometer. We need the two holes to be aligned on either side of the front post. Most often, they won\u2019t be aligned initially. At this point, take note of which way part of the post is facing the front of the module. Use a sharpie to mark the corner of the hex nut which pointed to the front of the module Remove the nut and reinster with the marked corner now oriented in between the two holes Screw the spool 1 back onto the module base Grab the spool 2 part and a badge reel Cut the end of the badge reel string off Use a pair of pliers or wire cutters to break open the badge reel, crushing the opening worked well on my badge reels Extract the spring and the string from the badge reel. You can throw the rest out. Cut spring to a little under 10 inches, no need to be precise Put a little bend in the cut end, it should only be maybe 2-3mm long, this will hold it in the potentiometer slot without slipping out. Before winding the spring make sure the potentiometer is turned fully in one direction. This should be clockwise if the module you are making is going to have the string coming out on the right side of the module. It will be counterclockwise if the string comes out on the left side. This guide is showing a module where the string comes out to the right, iIf you are assembling a module where the string comes out on the left side, the direction of all winding in this guide should be reversed. The modules where the string will come out to the right include Right Hand (RH) pointer, and middle, and LH ring, pinky, and thumb. The modules where the string will come out to the left include RH ring, pinky, and thumb, and LH pointer and middle. Starting with the flanged end, insert it through the sqaure hole on the left, you\u2019ll need to come in at an angle. You want the little divet to be passing through the square hole, the short end inside the inner area, and the rest of the spring coming out. Start winding the spring counterclockwise, you\u2019ll move it to the inner area right away, this motion should cause the flanged end to be pushed against the side wall as shown here. As you are winding, you\u2019ll also be guiding it down in line with the flanged end. You\u2019ll want to be holding it down with one thumb, while you use the other hand to move the free end. The next three images show how I hold down the spooled spring, guide the free end around, and switch thumbs as I continue to guide in the free end of the spring. Once you get the rhythm of it, it isn\u2019t too difficult. Once you reach the end of the spring, use a pair of needle nose pliers to grab the very end before the bend, curve it around a little more and place it in the slot of the potentiometer. The spring might need to stretch a little bit in order to reach the slot, that\u2019s okay and it will put a little tension on the potentiometer in it\u2019s resting position, which is good. It should look like this. Use your pliers to push the spring down into place if needed. We want it to be nice, neat, and all in line with itself, not coming up and down at different spots. Thread the string though the hole in the upper spool. Start winding to the right (clockwise if you look from below, counterclockwise if you look from above). Try to wind it fairly tight. I like to just wind up until I can\u2019t wind without stacking it on itself (usually 5 or so winds). This will keep it flat against the spool. Thread the string though the hole in the lower spool. Bring the upper spool down into place, while keeping some tension on the end of the string. Just shoving it in will cause the string to get all fucked up in there. Keep tension as you push the upper spool down onto the potentiometer Insert the other potentiometer, and tighten it into place with the hex nut Position the potentiometer shaft so that it is halfway through its rotation range. Than press the splay linkage onto the potentiometer shaft. Assemble all of the modules in this fashion. Now on to the larger assembly. Cut two 12\u201d strips of omni tape for each glove. May be shorter or longer depending on hand size. Fasten the straps to the outside edge of the baseplate as shown. Either sew or glue this end to itself to create a tight anchor point for the straps. Running the straps through the other slots on the baseplate, fasten the baseplate to the glove on your hand. Find a position that feels comfortable on your hand and where you think the modules will be positioned in line with their respective fingers. Once you find this potion, use a hot glue gun to glue the baseplate down to the glove in that position. I prefer to be wearing the glove when I do this, so I can feel and adjust the position as I am gluing. Once that is dry, put the modules on the baseplate. They slide on and then the retainers snap into the baseplate to keep them in place. Find a comfortable position for the end of the splay node and glue it to the glove using hot glue. You should be able to comfortably open/close your hand fully. You should also be able to splay your fingers with the linkage naturally following, this can be trickiest for the thumb. It should also be generally around the first finger knuckle so it can guide the string at that point. Do this for every finger. Glue the finger rings onto each finger. They should be past the last finger knuckle so the wide portion engages with the finger pad. They shouldn\u2019t be on the center of your finger pad as you still want to be able to feel and use your fingers. The adjacent finger rings should naturally stagger with the lengths of your fingers, if they are even with each other then they may bump into each other which will be more noticeable when using the final product. Next use a needle threading tool to thread the string from each module through the two holes on the splay node, and the lower hole on the finger ring. Thread the string back through the top hole of the finger ring. Pull the string taut and tie a double overhand knot at the finger ring. Start by passing the end of the string under the thread running in between the splay node and finger ring. Pass the end of the string through the loop created by the previous step. Then pull tight. Repeat to create a second knot on top. Before pulling the knot tight, make sure the main line is tight. The fingers on the glove should be in the fully extended position, then pull the string coming out of the top hole on the finger ring right before tightening the knot. This is important so that the string is the right length so that the zero position of the reel is at full extension. You may need to adjust the tightness in this step.","title":"Mechanical Assembly Guide"},{"location":"docs/parts_list/","text":"Parts List Electronics ESP32 WROOM REV 1 There's a million of these guys on Amazon and friends, and they're usually around $5-10 a pop. Fantastic microcontroller, and is the heart and soul of this project. Specifically, you need one with this pinout: ClearGauntlet PCB This PCB is still in active development, so I'd hold off on ordering unless you intend to help us work on it. If you're local to Rochester, NY, I have a few Rev B spares I could lend you! ... and much, MUCH more!","title":"Parts List"},{"location":"docs/parts_list/#parts-list","text":"","title":"Parts List"},{"location":"docs/parts_list/#electronics","text":"","title":"Electronics"},{"location":"docs/parts_list/#esp32-wroom-rev-1","text":"There's a million of these guys on Amazon and friends, and they're usually around $5-10 a pop. Fantastic microcontroller, and is the heart and soul of this project. Specifically, you need one with this pinout:","title":"ESP32 WROOM REV 1"},{"location":"docs/parts_list/#cleargauntlet-pcb","text":"This PCB is still in active development, so I'd hold off on ordering unless you intend to help us work on it. If you're local to Rochester, NY, I have a few Rev B spares I could lend you! ... and much, MUCH more!","title":"ClearGauntlet PCB"},{"location":"docs/power/","text":"CG Proto 2 Power Guide Soldering the Batteries I don\u2019t really have any authority to speak on whether or not you should solder batteries, but I\u2019ve heard that generally it\u2019s not a good idea, but you can do it. In my experience, it works. This is my method. It\u2019s probably not the best, but it works. To get familiar with the concept of applying molten metal to bombs that explode really slowly, I watched this video: https://www.youtube.com/watch?v=Zx7d5yJdWp0 You must ensure that you have cells that you _can _solder to (such as these: https://www.18650batterystore.com/products/samsung-35e ). Wrap your batteries in fish paper . This is a very insulating material, and will form a good rigid \u201cbody\u201d for your battery. The kind I use has adhesive on one side, which makes assembly very easy. Then, with a screwdriver, scrape the anode of the battery. This will remove oxidation and make solder stick much more easily. Immediately afterwards, get a blob of solder on there with your iron. I set mine to 410 degrees Celsius. The reason you want it so hot is because you wanna spend as little time soldering the cell as possible. Speed is the name of the game here. Get your solder on there quick, and get your iron out of there quicker. Do not hold your iron to the cell for longer than 5 seconds. At best, it will degrade your battery, and at worst, you\u2019ll have some cool burns. We\u2019ve got three blobs on there: Two for connecting the batteries, one for the wire going to the BMS. Note: You should try to solder the edges, rather than the center, as that will be less likely to cause damage to the cell. Instead of doing what I did, you should probably remove some of the pink shielding and solder to the side of the cell, as that is negatively charged. Next, cut a wire to connect the batteries. I use copper, solid core, 22AWG. Put it across the battery as shown below. I find that it helps to secure it in place with tape. Once again, scrape oxidation off the solder blob, grab your rosin core solder, then get your iron on there quick . Five seconds max should do it. Use extra solder to get things to liquify and adhere. Nice. Once you\u2019re done with that, flip the battery to the cathode. You\u2019re gonna do the same thing, with one key difference: Since we\u2019re soldering cells in parallel, we want the BMS positive wire to be on the opposite cell from the BMS negative wire. For example, if you\u2019re looking at your battery from one side, and you soldered the extra blob on the negative side onto the left cell, you\u2019ll want the extra blob on the positive side to be on the right cell. This will help ensure that current moves through both cells relatively evenly. Now, it\u2019s time to attach the BMS. First, solder two wires of generous length to the extra solder blobs. These will connect to the BMS. I used electrical tape to hold them down while I solder them. It is extremely important that you do not let these wires touch. You will get cool-looking electrical burns. Cut the XT30 really short. There should be almost no cable jutting out from the pack. We won\u2019t need it. That\u2019s basically it. I like to secure the connector in place with some electrical tape, then wrap the whole thing in a layer or two of kapton tape.","title":"Power"},{"location":"docs/power/#cg-proto-2-power-guide","text":"","title":"CG Proto 2 Power Guide"},{"location":"docs/power/#soldering-the-batteries","text":"I don\u2019t really have any authority to speak on whether or not you should solder batteries, but I\u2019ve heard that generally it\u2019s not a good idea, but you can do it. In my experience, it works. This is my method. It\u2019s probably not the best, but it works. To get familiar with the concept of applying molten metal to bombs that explode really slowly, I watched this video: https://www.youtube.com/watch?v=Zx7d5yJdWp0 You must ensure that you have cells that you _can _solder to (such as these: https://www.18650batterystore.com/products/samsung-35e ). Wrap your batteries in fish paper . This is a very insulating material, and will form a good rigid \u201cbody\u201d for your battery. The kind I use has adhesive on one side, which makes assembly very easy. Then, with a screwdriver, scrape the anode of the battery. This will remove oxidation and make solder stick much more easily. Immediately afterwards, get a blob of solder on there with your iron. I set mine to 410 degrees Celsius. The reason you want it so hot is because you wanna spend as little time soldering the cell as possible. Speed is the name of the game here. Get your solder on there quick, and get your iron out of there quicker. Do not hold your iron to the cell for longer than 5 seconds. At best, it will degrade your battery, and at worst, you\u2019ll have some cool burns. We\u2019ve got three blobs on there: Two for connecting the batteries, one for the wire going to the BMS. Note: You should try to solder the edges, rather than the center, as that will be less likely to cause damage to the cell. Instead of doing what I did, you should probably remove some of the pink shielding and solder to the side of the cell, as that is negatively charged. Next, cut a wire to connect the batteries. I use copper, solid core, 22AWG. Put it across the battery as shown below. I find that it helps to secure it in place with tape. Once again, scrape oxidation off the solder blob, grab your rosin core solder, then get your iron on there quick . Five seconds max should do it. Use extra solder to get things to liquify and adhere. Nice. Once you\u2019re done with that, flip the battery to the cathode. You\u2019re gonna do the same thing, with one key difference: Since we\u2019re soldering cells in parallel, we want the BMS positive wire to be on the opposite cell from the BMS negative wire. For example, if you\u2019re looking at your battery from one side, and you soldered the extra blob on the negative side onto the left cell, you\u2019ll want the extra blob on the positive side to be on the right cell. This will help ensure that current moves through both cells relatively evenly. Now, it\u2019s time to attach the BMS. First, solder two wires of generous length to the extra solder blobs. These will connect to the BMS. I used electrical tape to hold them down while I solder them. It is extremely important that you do not let these wires touch. You will get cool-looking electrical burns. Cut the XT30 really short. There should be almost no cable jutting out from the pack. We won\u2019t need it. That\u2019s basically it. I like to secure the connector in place with some electrical tape, then wrap the whole thing in a layer or two of kapton tape.","title":"Soldering the Batteries"}]}